// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package betalinkauth

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createEmailVerification = `-- name: CreateEmailVerification :exec
INSERT INTO EmailVerification (user_id, verification_token) VALUES ($1, $2)
`

type CreateEmailVerificationParams struct {
	UserID            pgtype.UUID
	VerificationToken string
}

func (q *Queries) CreateEmailVerification(ctx context.Context, arg CreateEmailVerificationParams) error {
	_, err := q.db.Exec(ctx, createEmailVerification, arg.UserID, arg.VerificationToken)
	return err
}

const createPasswordRecovery = `-- name: CreatePasswordRecovery :exec
INSERT INTO PasswordRecovery (user_id, recovery_token) VALUES ($1, $2)
`

type CreatePasswordRecoveryParams struct {
	UserID        pgtype.UUID
	RecoveryToken string
}

func (q *Queries) CreatePasswordRecovery(ctx context.Context, arg CreatePasswordRecoveryParams) error {
	_, err := q.db.Exec(ctx, createPasswordRecovery, arg.UserID, arg.RecoveryToken)
	return err
}

const createSession = `-- name: CreateSession :one
INSERT INTO Sessions (user_id, created_at, updated_at, expires_at) VALUES ($1, $2, $3, $4) RETURNING session_id
`

type CreateSessionParams struct {
	UserID    pgtype.UUID
	CreatedAt pgtype.Timestamptz
	UpdatedAt pgtype.Timestamptz
	ExpiresAt pgtype.Timestamptz
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createSession,
		arg.UserID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.ExpiresAt,
	)
	var session_id pgtype.UUID
	err := row.Scan(&session_id)
	return session_id, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO Users (first_name, last_name) VALUES ($1, $2) RETURNING user_id
`

type CreateUserParams struct {
	FirstName string
	LastName  string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createUser, arg.FirstName, arg.LastName)
	var user_id pgtype.UUID
	err := row.Scan(&user_id)
	return user_id, err
}

const createUserLoginData = `-- name: CreateUserLoginData :exec
INSERT INTO UsersLoginData (user_id, email, passwordHash, passwordSalt, hashAlgorithm) VALUES ($1, $2, $3, $4, $5)
`

type CreateUserLoginDataParams struct {
	UserID        pgtype.UUID
	Email         string
	Passwordhash  string
	Passwordsalt  string
	Hashalgorithm string
}

func (q *Queries) CreateUserLoginData(ctx context.Context, arg CreateUserLoginDataParams) error {
	_, err := q.db.Exec(ctx, createUserLoginData,
		arg.UserID,
		arg.Email,
		arg.Passwordhash,
		arg.Passwordsalt,
		arg.Hashalgorithm,
	)
	return err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM Sessions WHERE session_id = $1
`

func (q *Queries) DeleteSession(ctx context.Context, sessionID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteSession, sessionID)
	return err
}

const getLoginDataByEmail = `-- name: GetLoginDataByEmail :one
SELECT user_id, email, passwordHash, passwordSalt, hashAlgorithm FROM UsersLoginData WHERE email = $1
`

func (q *Queries) GetLoginDataByEmail(ctx context.Context, email string) (Userslogindatum, error) {
	row := q.db.QueryRow(ctx, getLoginDataByEmail, email)
	var i Userslogindatum
	err := row.Scan(
		&i.UserID,
		&i.Email,
		&i.Passwordhash,
		&i.Passwordsalt,
		&i.Hashalgorithm,
	)
	return i, err
}

const getSessionById = `-- name: GetSessionById :one
SELECT session_id, user_id, created_at, updated_at, expires_at FROM Sessions WHERE session_id = $1
`

func (q *Queries) GetSessionById(ctx context.Context, sessionID pgtype.UUID) (Session, error) {
	row := q.db.QueryRow(ctx, getSessionById, sessionID)
	var i Session
	err := row.Scan(
		&i.SessionID,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const getUserById = `-- name: GetUserById :one
SELECT user_id, first_name, last_name FROM Users WHERE user_id = $1
`

type GetUserByIdRow struct {
	UserID    pgtype.UUID
	FirstName string
	LastName  string
}

func (q *Queries) GetUserById(ctx context.Context, userID pgtype.UUID) (GetUserByIdRow, error) {
	row := q.db.QueryRow(ctx, getUserById, userID)
	var i GetUserByIdRow
	err := row.Scan(&i.UserID, &i.FirstName, &i.LastName)
	return i, err
}

const test_UpdateSessionExpiresAt = `-- name: Test_UpdateSessionExpiresAt :exec
UPDATE Sessions SET expires_at = $1 WHERE session_id = $2
`

type Test_UpdateSessionExpiresAtParams struct {
	ExpiresAt pgtype.Timestamptz
	SessionID pgtype.UUID
}

func (q *Queries) Test_UpdateSessionExpiresAt(ctx context.Context, arg Test_UpdateSessionExpiresAtParams) error {
	_, err := q.db.Exec(ctx, test_UpdateSessionExpiresAt, arg.ExpiresAt, arg.SessionID)
	return err
}
